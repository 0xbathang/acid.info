"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPromise = exports.ResultType = void 0;
const tslib_1 = require("tslib");
// @ts-ignore
const fetchIndexes_1 = require("@easyops-cn/docusaurus-search-local/dist/client/client/theme/SearchBar/fetchIndexes");
// @ts-ignore
const getStemmedPositions_1 = require("@easyops-cn/docusaurus-search-local/dist/client/client/utils/getStemmedPositions");
// @ts-ignore
const highlightStemmed_1 = require("@easyops-cn/docusaurus-search-local/dist/client/client/utils/highlightStemmed");
// @ts-ignore
const SearchSourceFactory_1 = require("@easyops-cn/docusaurus-search-local/dist/client/client/utils/SearchSourceFactory");
// @ts-ignore
const proxied = tslib_1.__importStar(require("@easyops-cn/docusaurus-search-local/dist/client/client/utils/proxiedGenerated"));
const loadIndex = async (params) => {
    const { wrappedIndexes, zhDictionary } = await (0, fetchIndexes_1.fetchIndexes)(params.versionUrl, params.searchContext);
    return { wrappedIndexes, zhDictionary };
};
const findSearchContext = ({ versionUrl, searchContextByPaths, }) => {
    let pathname = window.location.pathname;
    pathname = pathname.endsWith('/') ? pathname : pathname + '/';
    if (!Array.isArray(searchContextByPaths) || !pathname.startsWith(versionUrl))
        return '';
    const uri = pathname.substring(versionUrl.length);
    const paths = searchContextByPaths;
    return paths.find((path) => uri === path || uri.startsWith(`${path}/`)) ?? '';
};
class Search {
    constructor(config) {
        this.config = config;
        this.loading = false;
        this.source = null;
        this.init = async () => {
            this.loading = true;
            const { wrappedIndexes, zhDictionary } = await loadIndex({
                versionUrl: this.baseUrl,
                searchContext: findSearchContext({
                    versionUrl: this.baseUrl,
                    searchContextByPaths: this.searchContextByPaths,
                }),
            });
            this.source = (0, SearchSourceFactory_1.SearchSourceFactory)(wrappedIndexes, zhDictionary, this.config.resultsLimit);
        };
        this.query = async (input) => {
            if (!this.source)
                throw new Error('Not initialized');
            const { promise, callback } = (0, exports.createPromise)();
            this.source && this.source(input, callback);
            return {
                results: (await promise).map((result) => this.formatResult(result)),
            };
        };
        this.formatResult = (result) => {
            return {
                ...result,
                type: this.resultTypeToString(result.type),
                page: result.page ? this.formatDocument(result.page) : null,
                document: result.document ? this.formatDocument(result.document) : null,
                highlighted: (0, highlightStemmed_1.highlightStemmed)(result.document.t, (0, getStemmedPositions_1.getStemmedPositions)(result.metadata, 't'), result.tokens),
            };
        };
        this.resultTypeToString = (type) => ({ 0: ResultType.Title, 1: ResultType.Heading, 2: ResultType.Paragraph }[type]);
        this.formatDocument = (doc) => {
            return {
                id: doc.i,
                title: doc.t,
                url: doc.u,
                hash: doc.h,
                parentId: doc.p,
                breadcrumb: doc.b,
                sectionTitle: doc.s,
            };
        };
        this.baseUrl = config.preferredVersionPath;
        this.searchContextByPaths = config.searchContextByPaths ?? '';
    }
}
var ResultType;
(function (ResultType) {
    ResultType["Title"] = "title";
    ResultType["Heading"] = "heading";
    ResultType["Paragraph"] = "paragraph";
})(ResultType = exports.ResultType || (exports.ResultType = {}));
const createPromise = () => {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    const callback = (data, error) => {
        if (error)
            return void reject(error);
        resolve(data);
    };
    return {
        reject,
        resolve,
        promise,
        callback,
    };
};
exports.createPromise = createPromise;
const main = async () => {
    if (typeof window === 'undefined')
        return;
    const win = window;
    win.getProxiedGeneratedData = () => proxied;
    win.createSearchInstance = async (config) => {
        const search = new Search(config);
        return search;
    };
};
main();
